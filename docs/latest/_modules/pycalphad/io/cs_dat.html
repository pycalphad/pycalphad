<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <meta name="generator" content="sphinx-4.5.0, furo 2021.10.09"/>
        <title>pycalphad.io.cs_dat - pycalphad 0.10.2.dev9+g62d653fe documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=0254c309f5cadf746f1a613e7677379ac9c8cdcd" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=16fb25fabf47304eee183a5e9af80b1ba98259b1" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  body[data-theme="dark"] {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
  @media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }
</style></head>
  <body>
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" />
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">pycalphad 0.10.2.dev9+g62d653fe documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../../_static/pycalphad-logo-withtext.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">pycalphad 0.10.2.dev9+g62d653fe documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../INSTALLING.html">Install pycalphad</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../examples/index.html">Examples</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/BinaryExamples.html">Plotting Isobaric Binary Phase Diagrams with <code class="docutils literal notranslate"><span class="pre">binplot</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/BinaryExamples.html#Calculating-Energy-Surfaces-of-Binary-Systems">Calculating Energy Surfaces of Binary Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/TernaryExamples.html">Plotting Ternary Phase Diagrams and Using Triangular Axes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/UsingCalculationResults.html">Exploring <code class="docutils literal notranslate"><span class="pre">calculate</span></code> and <code class="docutils literal notranslate"><span class="pre">equilibrium</span></code> xarray Datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/ChargedPhases.html">Phases with Electrically Charged Species</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/ReferenceStateExamples.html">Calculations with Reference States</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/PlotActivity.html">Calculate and Plot Activity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/EquilibriumWithOrdering.html">Equilibrium Properties and Partial Ordering (Al-Fe and Al-Ni)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/ViscosityModel.html">Custom Models in pycalphad: Viscosity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples/CementiteAnalysis.html">Heat Capacity of Cementite (<span class="math notranslate nohighlight">\(Fe_3C\)</span>)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../CHANGES.html">Whatâ€™s New</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../releasing.html">Releasing pycalphad</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../onboarding.html">Onboarding as a Developer</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../api/modules.html">API Documentation</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/pycalphad.html">pycalphad package</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/pycalphad.codegen.html">pycalphad.codegen package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/pycalphad.core.html">pycalphad.core package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/pycalphad.io.html">pycalphad.io package</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/pycalphad.models.html">pycalphad.models package</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/pycalphad.plot.html">pycalphad.plot package</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/pycalphad.plot.binary.html">pycalphad.plot.binary package</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for pycalphad.io.cs_dat</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">Support for reading ChemSage DAT files.</span>
<span class="sd">"""</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">symengine</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">,</span> <span class="n">And</span>
<span class="kn">from</span> <span class="nn">pycalphad</span> <span class="kn">import</span> <span class="n">Database</span><span class="p">,</span> <span class="n">variables</span> <span class="k">as</span> <span class="n">v</span>
<span class="kn">from</span> <span class="nn">.grammar</span> <span class="kn">import</span> <span class="n">parse_chemical_formula</span>

<span class="c1"># From ChemApp Documentation, section 11.1 "The format of a ChemApp data-file"</span>
<span class="c1"># We use a leading zero term because the data file's indices are 1-indexed and</span>
<span class="c1"># this prevents us from needing to shift the indicies.</span>
<span class="c1"># Exponents are in floating point so that round-trip write/read passes equality checks</span>
<span class="n">GIBBS_TERMS</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">**</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">**</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">))</span>
<span class="n">CP_TERMS</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">**</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">))</span>
<span class="n">EXCESS_TERMS</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">**</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">**</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">P</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">DEFAULT_T_MIN</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># The same as for TDBs when no minimum temperature is given.</span>

<span class="k">def</span> <span class="nf">_parse_species_postfix_charge</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">Species</span><span class="p">:</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">formula</span>
    <span class="c1"># handle postfix charge: FE[2+] CU[+] CL[-] O[2-]</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">'\[([0-9]+)?([-+])\]'</span><span class="p">,</span> <span class="n">formula</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># remove the charge from the formula</span>
        <span class="n">formula</span> <span class="o">=</span> <span class="n">formula</span><span class="p">[:</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span>
        <span class="n">charge</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="si">}{</span><span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="mi">1</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">charge</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># assumes that the remaining formula is a pure element</span>
    <span class="n">constituents</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">parse_chemical_formula</span><span class="p">(</span><span class="n">formula</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">Species</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">constituents</span><span class="o">=</span><span class="n">constituents</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">charge</span><span class="p">)</span>

<div class="viewcode-block" id="TokenParserError"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.TokenParserError">[docs]</a><span class="k">class</span> <span class="nc">TokenParserError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">"""Exception raised when the TokenParser hits a parsing error."""</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="TokenParser"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.TokenParser">[docs]</a><span class="k">class</span> <span class="nc">TokenParser</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_number</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># user facing, so make it one-indexed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lines_deque</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lines_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokens_deque</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># Instantiate a new TokenParser for the current state so we can look ahead without messing up our line numbers</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">deque</span><span class="p">([</span><span class="s2">" "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokens_deque</span><span class="p">)])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lines_deque</span><span class="p">)</span>
        <span class="n">tmp_parser</span> <span class="o">=</span> <span class="n">TokenParser</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">token</span> <span class="o">=</span> <span class="n">tmp_parser</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tmp_parser</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># If we're out of tokens, get the next line and try to grab a token again</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lines_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_line_number</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tokens_deque</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
            <span class="c1"># call next instead of popleft() on the deque in case self._current_line has no tokens</span>
            <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">token</span>

<div class="viewcode-block" id="TokenParser.parse"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.TokenParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">next_token</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Return the token and re-raise with a ParseError </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tokens_deque</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">next_token</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">TokenParserError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Error at line number </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_line_number</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="si">}</span><span class="s2"> for line:</span><span class="se">\n</span><span class="s2">    </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_line</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="TokenParser.parseN"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.TokenParser.parseN">[docs]</a>    <span class="k">def</span> <span class="nf">parseN</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">'N must be &gt;=1, got </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span></div></div>


<div class="viewcode-block" id="Header"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Header">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Header</span><span class="p">:</span>
    <span class="n">list_soln_species_count</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">num_stoich_phases</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">pure_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">pure_elements_mass</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">gibbs_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">excess_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span></div>


<div class="viewcode-block" id="AdditionalCoefficientPair"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.AdditionalCoefficientPair">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">AdditionalCoefficientPair</span><span class="p">:</span>
    <span class="n">coefficient</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">exponent</span><span class="p">:</span> <span class="nb">float</span>

<div class="viewcode-block" id="AdditionalCoefficientPair.expr"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.AdditionalCoefficientPair.expr">[docs]</a>    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">99</span><span class="p">:</span>
            <span class="c1"># this is a special case and means log(v.T)</span>
            <span class="c1"># See ChemApp documentation, section 11.1 cosi.dat, Line 5</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Additional coefficient pair has an exponent of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="si">}</span><span class="s2">, which should be between -9 and +9."</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficient</span> <span class="o">*</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PTVmTerms"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.PTVmTerms">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PTVmTerms</span><span class="p">:</span>
    <span class="n">terms</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span></div>


<div class="viewcode-block" id="IntervalBase"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.IntervalBase">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">IntervalBase</span><span class="p">:</span>
    <span class="n">T_max</span><span class="p">:</span> <span class="nb">float</span>

<div class="viewcode-block" id="IntervalBase.expr"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.IntervalBase.expr">[docs]</a>    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Subclasses of IntervalBase must define an expression for the energy"</span><span class="p">)</span></div>

<div class="viewcode-block" id="IntervalBase.cond"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.IntervalBase.cond">[docs]</a>    <span class="k">def</span> <span class="nf">cond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T_min</span><span class="o">=</span><span class="n">DEFAULT_T_MIN</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">T_min</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_max</span><span class="p">:</span>
            <span class="c1"># To avoid an impossible, always False condition an open interval</span>
            <span class="c1"># is assumed. We choose 10000 K as the dummy (as in TDBs).</span>
            <span class="k">return</span> <span class="n">And</span><span class="p">((</span><span class="n">T_min</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">And</span><span class="p">((</span><span class="n">T_min</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_max</span><span class="p">))</span></div>

<div class="viewcode-block" id="IntervalBase.expr_cond_pair"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.IntervalBase.expr_cond_pair">[docs]</a>    <span class="k">def</span> <span class="nf">expr_cond_pair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">T_min</span><span class="o">=</span><span class="n">DEFAULT_T_MIN</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Return an (expr, cond) tuple used to construct Piecewise expressions"""</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">T_min</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="IntervalG"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.IntervalG">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">IntervalG</span><span class="p">(</span><span class="n">IntervalBase</span><span class="p">):</span>
    <span class="n">coefficients</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">additional_coeff_pairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AdditionalCoefficientPair</span><span class="p">]</span>
    <span class="n">PTVm_terms</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PTVmTerms</span><span class="p">]</span>

<div class="viewcode-block" id="IntervalG.expr"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.IntervalG.expr">[docs]</a>    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">"""Return an expression for the energy in this temperature interval"""</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="c1"># Add fixed energy terms</span>
        <span class="n">energy</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">C</span><span class="o">*</span><span class="n">GIBBS_TERMS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">C</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">indices</span><span class="p">)])</span>
        <span class="c1"># Add additional energy coefficient-exponent pair terms</span>
        <span class="n">energy</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">addit_term</span><span class="o">.</span><span class="n">expr</span><span class="p">()</span> <span class="k">for</span> <span class="n">addit_term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_coeff_pairs</span><span class="p">])</span>
        <span class="c1"># P-T molar volume terms, not supported</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PTVm_terms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"P-T molar volume terms are not supported"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">energy</span></div></div>


<span class="c1"># TODO: not yet supported</span>
<div class="viewcode-block" id="IntervalCP"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.IntervalCP">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">IntervalCP</span><span class="p">(</span><span class="n">IntervalBase</span><span class="p">):</span>
    <span class="c1"># Fixed term heat capacity interval with extended terms</span>
    <span class="n">H298</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">S298</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">CP_coefficients</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">H_trans</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">additional_coeff_pairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AdditionalCoefficientPair</span><span class="p">]</span>
    <span class="n">PTVm_terms</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PTVmTerms</span><span class="p">]</span>

<div class="viewcode-block" id="IntervalCP.expr"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.IntervalCP.expr">[docs]</a>    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">T_min</span><span class="o">=</span><span class="n">DEFAULT_T_MIN</span><span class="p">):</span>
        <span class="sd">"""Return an expression for the energy in this temperature interval"""</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Heat capacity descriptions of the Gibbs energy are not implemented."</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Endmember"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Endmember">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Endmember</span><span class="p">():</span>
    <span class="n">species_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">gibbs_eq_type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">stoichiometry_pure_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">IntervalBase</span><span class="p">]</span>

<div class="viewcode-block" id="Endmember.expr"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Endmember.expr">[docs]</a>    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">"""Return a Piecewise (in temperature) energy expression for this endmember (i.e. only the data from the energy intervals)"""</span>
        <span class="n">T_min</span> <span class="o">=</span> <span class="n">DEFAULT_T_MIN</span>
        <span class="n">expr_cond_pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervals</span><span class="p">:</span>
            <span class="n">expr_cond_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">expr_cond_pair</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">T_min</span><span class="o">=</span><span class="n">T_min</span><span class="p">))</span>
            <span class="n">T_min</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">T_max</span>
        <span class="c1"># a (expr, True) condition must be at the end</span>
        <span class="n">expr_cond_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">true</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Piecewise</span><span class="p">(</span><span class="o">*</span><span class="n">expr_cond_pairs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Endmember.constituents"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Endmember.constituents">[docs]</a>    <span class="k">def</span> <span class="nf">constituents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pure_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">el</span><span class="p">:</span> <span class="n">amnt</span> <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">amnt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pure_elements</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stoichiometry_pure_elements</span><span class="p">)</span> <span class="k">if</span> <span class="n">amnt</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">}</span></div>

<div class="viewcode-block" id="Endmember.constituent_array"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Endmember.constituent_array">[docs]</a>    <span class="k">def</span> <span class="nf">constituent_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">sp</span><span class="p">]</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">':'</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Endmember.species"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Endmember.species">[docs]</a>    <span class="k">def</span> <span class="nf">species</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pure_elements</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">Species</span><span class="p">]:</span>
        <span class="sd">"""Return an unordered list of Species objects detected in this endmember"""</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">':'</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If given in sublattice notation, assume species are pure elements</span>
            <span class="c1"># i.e. multi-sublattice models cannot have associates</span>
            <span class="n">all_species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">species_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">':'</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">Species</span><span class="p">(</span><span class="n">sp_str</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp_str</span> <span class="ow">in</span> <span class="n">all_species</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We only have one sublattice, this can be a non-pure element species</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">Species</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species_name</span><span class="p">,</span> <span class="n">constituents</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">constituents</span><span class="p">(</span><span class="n">pure_elements</span><span class="p">))]</span></div>

<div class="viewcode-block" id="Endmember.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Endmember.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s1">'G'</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">(</span><span class="n">gibbs_coefficient_idxs</span><span class="p">),</span> <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="EndmemberQKTO"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.EndmemberQKTO">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">EndmemberQKTO</span><span class="p">(</span><span class="n">Endmember</span><span class="p">):</span>
    <span class="n">stoichiometric_factor</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">chemical_group</span><span class="p">:</span> <span class="nb">int</span>

<div class="viewcode-block" id="EndmemberQKTO.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.EndmemberQKTO.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s1">'G'</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">(</span><span class="n">gibbs_coefficient_idxs</span><span class="p">),</span> <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Most databases in the wild use stoichiometric factors of unity,</span>
        <span class="c1"># so we're avoiding the complexity of non-unity factors for now.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_factor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"QKTO endmembers with stoichiometric factors other than 1 are not yet supported. For </span><span class="si">{</span><span class="n">phase_name</span><span class="si">}</span><span class="s2">: got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stoichiometric_factor</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="EndmemberMagnetic"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.EndmemberMagnetic">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">EndmemberMagnetic</span><span class="p">(</span><span class="n">Endmember</span><span class="p">):</span>
    <span class="n">curie_temperature</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">magnetic_moment</span><span class="p">:</span> <span class="nb">float</span>

<div class="viewcode-block" id="EndmemberMagnetic.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.EndmemberMagnetic.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pure_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="c1"># add Gibbs energy</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">pure_elements</span><span class="p">,</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">)</span>

        <span class="c1"># also add magnetic parameters</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s1">'BMAGN'</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">(),</span>
                          <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnetic_moment</span><span class="p">,</span> <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s1">'TC'</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">(),</span>
                          <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curie_temperature</span><span class="p">,</span> <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="EndmemberRealGas"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.EndmemberRealGas">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">EndmemberRealGas</span><span class="p">(</span><span class="n">Endmember</span><span class="p">):</span>
    <span class="c1"># Tsonopoulos data</span>
    <span class="n">Tc</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Pc</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">Vc</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">acentric_factor</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">dipole_moment</span><span class="p">:</span> <span class="nb">float</span>

<div class="viewcode-block" id="EndmemberRealGas.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.EndmemberRealGas.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Inserting parameters for real gas Endmembers is not supported."</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="EndmemberAqueous"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.EndmemberAqueous">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">EndmemberAqueous</span><span class="p">(</span><span class="n">Endmember</span><span class="p">):</span>
    <span class="n">charge</span><span class="p">:</span> <span class="nb">float</span>

<div class="viewcode-block" id="EndmemberAqueous.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.EndmemberAqueous.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">"Inserting parameters for aqueous Endmembers is not supported."</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ExcessBase"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessBase">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ExcessBase</span><span class="p">:</span>
    <span class="n">interacting_species_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_map_const_idxs_to_subl_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_subl_species</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">"""</span>
<span class="sd">        Converts from one-indexed linear phase species indices to zero-indexed</span>
<span class="sd">        sublattice species indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_subl_species: List[int]</span>
<span class="sd">            Number of species in each sublattice, i.e. [1, 2, 1] could</span>
<span class="sd">            correspond to a sublattice model of [['A'], ['A', 'B'], ['C']]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[List[int]] - a list of species index lists</span>

<span class="sd">        """</span>
        <span class="n">cum_num_subl_species</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">num_subl_species</span><span class="p">)</span>
        <span class="c1"># initialize an empty sublattice model</span>
        <span class="n">subl_species_idxs</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">num_subl_species</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">linear_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interacting_species_idxs</span><span class="p">:</span>
            <span class="c1"># Find which sublattice this species belongs to by seeing that the</span>
            <span class="c1"># linear_idx is contained within the cumulative number of species</span>
            <span class="c1"># on each sublattice</span>
            <span class="n">subl_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">cum_num_subl_species</span> <span class="o">&gt;=</span> <span class="n">linear_idx</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Determine the index of the species within the sublattice</span>
            <span class="c1"># This is still the one-indexed value</span>
            <span class="k">if</span> <span class="n">subl_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">subl_sp_idx</span> <span class="o">=</span> <span class="n">linear_idx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subl_sp_idx</span> <span class="o">=</span> <span class="n">linear_idx</span> <span class="o">-</span> <span class="n">cum_num_subl_species</span><span class="p">[</span><span class="n">subl_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># convert one-indexed species index to zero-indexed</span>
            <span class="n">subl_sp_idx</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># add the species index to the right sublattice</span>
            <span class="n">subl_species_idxs</span><span class="p">[</span><span class="n">subl_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subl_sp_idx</span><span class="p">)</span>
        <span class="c1"># all sublattices must be occupied</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">subl</span> <span class="ow">in</span> <span class="n">subl_species_idxs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subl_species_idxs</span>

<div class="viewcode-block" id="ExcessBase.constituent_array"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessBase.constituent_array">[docs]</a>    <span class="k">def</span> <span class="nf">constituent_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phase_constituents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">"""</span>
<span class="sd">        Return the constituent array of this interaction using the entire phase</span>
<span class="sd">        sublattice model.</span>

<span class="sd">        This doesn't take into account any re-ordering of the phase_constituents</span>
<span class="sd">        or interacting_species_idxs. All mapping on to proper v.Species objects</span>
<span class="sd">        occurs in Database.add_parameter.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; phase_constituents = [['A'], ['A', 'B'], ['A', 'B', 'C']]</span>
<span class="sd">        &gt;&gt;&gt; ex = ExcessBase([1, 2, 4, 6])</span>
<span class="sd">        &gt;&gt;&gt; ix_const_arr = ex.constituent_array(phase_constituents)</span>
<span class="sd">        &gt;&gt;&gt; assert ix_const_arr == [['A'], ['A'], ['A', 'C']]</span>
<span class="sd">        """</span>
        <span class="n">num_subl_species</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">subl</span><span class="p">)</span> <span class="k">for</span> <span class="n">subl</span> <span class="ow">in</span> <span class="n">phase_constituents</span><span class="p">]</span>
        <span class="n">subl_species_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_const_idxs_to_subl_idxs</span><span class="p">(</span><span class="n">num_subl_species</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">phase_constituents</span><span class="p">[</span><span class="n">subl_idx</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">subl</span><span class="p">]</span> <span class="k">for</span> <span class="n">subl_idx</span><span class="p">,</span> <span class="n">subl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subl_species_idxs</span><span class="p">)]</span></div>

<div class="viewcode-block" id="ExcessBase.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessBase.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">phase_constituents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">excess_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Subclass </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> of ExcessBase must implement `insert` to add the phase, constituents and parameters to the Database."</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ExcessRKM"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessRKM">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ExcessRKM</span><span class="p">(</span><span class="n">ExcessBase</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; assert ExcessRKM([1, 2, 3, 4], 0, [0])._map_const_idxs_to_subl_idxs([2, 3]) == [[0, 1], [0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; assert ExcessRKM([1, 3, 4], 0, [0])._map_const_idxs_to_subl_idxs([2, 3]) == [[0], [0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; assert ExcessRKM([1, 2], 0, [0])._map_const_idxs_to_subl_idxs([4]) == [[0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; assert ExcessRKM([1, 2, 3], 0, [0])._map_const_idxs_to_subl_idxs([3]) == [[0, 1, 2]]</span>
<span class="sd">    &gt;&gt;&gt; assert ExcessRKM([1, 2, 3, 4], 0, [0])._map_const_idxs_to_subl_idxs([1, 1, 2]) == [[0], [0], [0, 1]]</span>
<span class="sd">    """</span>
    <span class="n">parameter_order</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">coefficients</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<div class="viewcode-block" id="ExcessRKM.expr"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessRKM.expr">[docs]</a>    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">"""Return an expression for the energy in this temperature interval"""</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="c1"># Add fixed energy terms</span>
        <span class="n">energy</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">C</span><span class="o">*</span><span class="n">EXCESS_TERMS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">C</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">indices</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">energy</span></div>

<div class="viewcode-block" id="ExcessRKM.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessRKM.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">phase_constituents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">excess_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">"""</span>
<span class="sd">        Requires all Species in dbf.species to be defined.</span>
<span class="sd">        """</span>
        <span class="c1"># Note: Thermochimica does _not_ sort species alphabetically (as is done by TDB formats),</span>
        <span class="c1"># so a constituent array of ("A", "B") != ("B", "A") for odd order terms.</span>
        <span class="n">const_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">(</span><span class="n">phase_constituents</span><span class="p">)</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s1">'L'</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">const_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">(</span><span class="n">excess_coefficient_idxs</span><span class="p">),</span> <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ExcessRKMMagnetic"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessRKMMagnetic">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ExcessRKMMagnetic</span><span class="p">(</span><span class="n">ExcessBase</span><span class="p">):</span>
    <span class="n">parameter_order</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">curie_temperature</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">magnetic_moment</span><span class="p">:</span> <span class="nb">float</span>

<div class="viewcode-block" id="ExcessRKMMagnetic.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessRKMMagnetic.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">phase_constituents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">excess_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">"""</span>
<span class="sd">        Requires all Species in dbf.species to be defined.</span>
<span class="sd">        """</span>
        <span class="c1"># See the comment about sorting in ExcessRKM</span>
        <span class="n">const_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">(</span><span class="n">phase_constituents</span><span class="p">)</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s1">'TC'</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">const_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curie_temperature</span><span class="p">,</span> <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span><span class="s1">'BMAGN'</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">const_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnetic_moment</span><span class="p">,</span> <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ExcessQKTO"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessQKTO">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ExcessQKTO</span><span class="p">(</span><span class="n">ExcessBase</span><span class="p">):</span>
    <span class="n">exponents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">coefficients</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<div class="viewcode-block" id="ExcessQKTO.expr"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessQKTO.expr">[docs]</a>    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">"""Return an expression for the energy in this temperature interval"""</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="c1"># Add fixed energy terms</span>
        <span class="n">energy</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">C</span><span class="o">*</span><span class="n">EXCESS_TERMS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">C</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coefficients</span><span class="p">,</span> <span class="n">indices</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">energy</span></div>

<div class="viewcode-block" id="ExcessQKTO.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.ExcessQKTO.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">phase_constituents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">excess_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">const_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">(</span><span class="n">phase_constituents</span><span class="p">)</span>
        <span class="n">exponents</span> <span class="o">=</span> <span class="p">[</span><span class="n">exponent</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">exponent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponents</span><span class="p">]</span>  <span class="c1"># For some reason, an exponent of 1 really means an exponent of zero</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span>
            <span class="s2">"QKT"</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">const_array</span><span class="p">,</span> <span class="n">param_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">param</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">(</span><span class="n">excess_coefficient_idxs</span><span class="p">),</span> <span class="n">exponents</span><span class="o">=</span><span class="n">exponents</span><span class="p">,</span>
            <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span></div></div>

<div class="viewcode-block" id="PhaseBase"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.PhaseBase">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PhaseBase</span><span class="p">:</span>
    <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">phase_type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">endmembers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Endmember</span><span class="p">]</span>

<div class="viewcode-block" id="PhaseBase.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.PhaseBase.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">pure_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">excess_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">"""Enter this phase and its parameters into the Database.</span>

<span class="sd">        This method should call:</span>

<span class="sd">        * `dbf.add_phase`</span>
<span class="sd">        * `dbf.structure_entry`</span>
<span class="sd">        * `dbf.add_phase_constituents`</span>
<span class="sd">        * `dbf.add_parameter` for all parameters</span>

<span class="sd">        """</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Subclass </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> of PhaseBase must implement `insert` to add the phase, constituents and parameters to the Database."</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Phase_Stoichiometric"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Phase_Stoichiometric">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Phase_Stoichiometric</span><span class="p">(</span><span class="n">PhaseBase</span><span class="p">):</span>
    <span class="n">magnetic_afm_factor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">magnetic_structure_factor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<div class="viewcode-block" id="Phase_Stoichiometric.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Phase_Stoichiometric.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">pure_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">excess_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">model_hints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnetic_afm_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnetic_structure_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This follows the Redlich-Kister Muggianu IHJ model. The ChemSage</span>
            <span class="c1"># docs don't indicate that it's an IHJ model, but Eriksson and Hack,</span>
            <span class="c1"># Met. Trans. B 21B (1990) 1013 says that it follows IHJ.</span>
            <span class="n">model_hints</span><span class="p">[</span><span class="s1">'ihj_magnetic_structure_factor'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnetic_structure_factor</span>
            <span class="c1"># The TDB syntax would define the AFM factor for FCC as -3</span>
            <span class="c1"># while ChemSage defines +0.333. This is likely because the</span>
            <span class="c1"># model divides by the AFM factor (-1/3). We convert the AFM</span>
            <span class="c1"># factor to the version used in the TDB/Model.</span>
            <span class="n">model_hints</span><span class="p">[</span><span class="s1">'ihj_magnetic_afm_factor'</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">magnetic_afm_factor</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># stoichiometric phase</span>

        <span class="c1"># For stoichiometric endmembers, the endmember "constituent array" is</span>
        <span class="c1"># just the phase name. We can just define the real constituent array in</span>
        <span class="c1"># terms of pure elements, where each element gets it's own sublattice.</span>
        <span class="n">constituent_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">constituents</span><span class="p">(</span><span class="n">pure_elements</span><span class="p">)</span>
        <span class="n">constituent_array</span> <span class="o">=</span> <span class="p">[[</span><span class="n">el</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">constituent_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>
        <span class="n">subl_stoich_ratios</span> <span class="o">=</span> <span class="p">[</span><span class="n">constituent_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">constituent_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>

        <span class="n">dbf</span><span class="o">.</span><span class="n">add_phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">model_hints</span><span class="o">=</span><span class="n">model_hints</span><span class="p">,</span> <span class="n">sublattices</span><span class="o">=</span><span class="n">subl_stoich_ratios</span><span class="p">)</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_structure_entry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">)</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_phase_constituents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">,</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Phase_CEF"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Phase_CEF">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Phase_CEF</span><span class="p">(</span><span class="n">PhaseBase</span><span class="p">):</span>
    <span class="n">subl_ratios</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">constituent_array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="n">endmember_constituent_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>
    <span class="n">excess_parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ExcessBase</span><span class="p">]</span>
    <span class="n">magnetic_afm_factor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">magnetic_structure_factor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<div class="viewcode-block" id="Phase_CEF.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Phase_CEF.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">pure_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">excess_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">model_hints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnetic_afm_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnetic_structure_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This follows the Redlich-Kister Muggianu IHJ model. The ChemSage</span>
            <span class="c1"># docs don't indicate that it's an IHJ model, but Eriksson and Hack,</span>
            <span class="c1"># Met. Trans. B 21B (1990) 1013 says that it follows IHJ.</span>
            <span class="n">model_hints</span><span class="p">[</span><span class="s1">'ihj_magnetic_structure_factor'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnetic_structure_factor</span>
            <span class="c1"># The TDB syntax would define the AFM factor for FCC as -3</span>
            <span class="c1"># while ChemSage defines +0.333. This is likely because the</span>
            <span class="c1"># model divides by the AFM factor (-1/3). We convert the AFM</span>
            <span class="c1"># factor to the version used in the TDB/Model.</span>
            <span class="n">model_hints</span><span class="p">[</span><span class="s1">'ihj_magnetic_afm_factor'</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">magnetic_afm_factor</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="p">(</span><span class="n">ExcessQKTO</span><span class="p">))</span> <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excess_parameters</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="p">(</span><span class="n">ExcessRKM</span><span class="p">))</span> <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excess_parameters</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"ExcessQKTO and ExcessRKM parameters found, but they cannot co-exist."</span><span class="p">)</span>

        <span class="c1"># Try adding model hints for chemical groups from endmembers</span>
        <span class="n">chemical_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">endmember</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">endmember</span><span class="p">,</span> <span class="s2">"chemical_group"</span><span class="p">):</span>
                <span class="n">endmember_species</span> <span class="o">=</span> <span class="n">endmember</span><span class="o">.</span><span class="n">species</span><span class="p">(</span><span class="n">pure_elements</span><span class="p">)</span>
                <span class="c1"># make the assumption that there's only one species in this endmember</span>
                <span class="c1"># currently, only QKTO model endmembers supply chemical groups</span>
                <span class="c1"># and QKTO models in the DAT can only have one sublattice.</span>
                <span class="n">species</span> <span class="o">=</span> <span class="n">endmember_species</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">chemical_groups</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Species </span><span class="si">{</span><span class="n">species</span><span class="si">}</span><span class="s2"> is already present in the chemical groups dictionary for phase </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="si">}</span><span class="s2">  with endmembers </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chemical_groups</span><span class="p">[</span><span class="n">species</span><span class="p">]</span> <span class="o">=</span> <span class="n">endmember</span><span class="o">.</span><span class="n">chemical_group</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chemical_groups</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">model_hints</span><span class="p">[</span><span class="s2">"chemical_groups"</span><span class="p">]</span> <span class="o">=</span> <span class="n">chemical_groups</span>

        <span class="n">dbf</span><span class="o">.</span><span class="n">add_phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">model_hints</span><span class="o">=</span><span class="n">model_hints</span><span class="p">,</span> <span class="n">sublattices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subl_ratios</span><span class="p">)</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_structure_entry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">)</span>

        <span class="c1"># This does two things:</span>
        <span class="c1"># 1. set the self.constituent_array</span>
        <span class="c1"># 2. add species to the database</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Before we add parameters, we need to first add all the species to dbf,</span>
            <span class="c1"># since dbf.add_parameter takes a constituent array of string species</span>
            <span class="c1"># names which are mapped to Species objects</span>
            <span class="k">for</span> <span class="n">endmember</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">endmember</span><span class="o">.</span><span class="n">species</span><span class="p">(</span><span class="n">pure_elements</span><span class="p">):</span>
                    <span class="n">invalid_shared_names</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sp</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">esp</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="n">sp</span> <span class="o">!=</span> <span class="n">esp</span><span class="p">)</span> <span class="k">for</span> <span class="n">esp</span> <span class="ow">in</span> <span class="n">dbf</span><span class="o">.</span><span class="n">species</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">invalid_shared_names</span><span class="p">):</span>
                        <span class="c1"># names match some already  but constituents do not</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"A Species named </span><span class="si">{</span><span class="n">sp</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> (defined for phase </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="si">}</span><span class="s2">) already exists in the database's species (</span><span class="si">{</span><span class="n">dbf</span><span class="o">.</span><span class="n">species</span><span class="si">}</span><span class="s2">), but the constituents do not match."</span><span class="p">)</span>
                    <span class="n">dbf</span><span class="o">.</span><span class="n">species</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

            <span class="c1"># Construct constituents for this phase, this loop could be merged with</span>
            <span class="c1"># the parameter additions above (it's not dependent like the species</span>
            <span class="c1"># step), but we are keeping it logically separate to make it clear how</span>
            <span class="c1"># it's working. This assumes that all constituents are present in</span>
            <span class="c1"># endmembers (i.e. there are no endmembers that are implicit).</span>

            <span class="n">constituents</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subl_ratios</span><span class="p">))]</span>
            <span class="k">for</span> <span class="n">endmember</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">subl</span><span class="p">,</span> <span class="n">const_subl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">endmember</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">(),</span> <span class="n">constituents</span><span class="p">):</span>
                    <span class="n">const_subl</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subl</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span> <span class="o">=</span> <span class="n">constituents</span>  <span class="c1"># Be careful to preserve ordering here, since the mapping from species indices to species depends on the order of this</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># add the species to the database</span>
            <span class="k">for</span> <span class="n">subl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">const</span> <span class="ow">in</span> <span class="n">subl</span><span class="p">:</span>
                    <span class="n">dbf</span><span class="o">.</span><span class="n">species</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_parse_species_postfix_charge</span><span class="p">(</span><span class="n">const</span><span class="p">))</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_phase_constituents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">)</span>

        <span class="c1"># Now that all the species are in the database, we are free to add the parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">endmember_constituent_idxs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we have to guess at the constituent array</span>
            <span class="k">for</span> <span class="n">endmember</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="p">:</span>
                <span class="n">endmember</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">endmember</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">(),</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we know the constituent array from the indices and we don't have</span>
            <span class="c1"># to guess</span>
            <span class="k">for</span> <span class="n">endmember</span><span class="p">,</span> <span class="n">const_idxs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endmember_constituent_idxs</span><span class="p">):</span>
                <span class="n">em_const_array</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sp_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sp_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">const_idxs</span><span class="p">)]</span>
                <span class="n">endmember</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">em_const_array</span><span class="p">,</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">excess_param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excess_parameters</span><span class="p">:</span>
            <span class="n">excess_param</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">,</span> <span class="n">excess_coefficient_idxs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="rename_element_charge"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.rename_element_charge">[docs]</a><span class="k">def</span> <span class="nf">rename_element_charge</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">charge</span><span class="p">):</span>
    <span class="sd">"""We use the _ to separate so we have something to split on."""</span>
    <span class="k">if</span> <span class="n">charge</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">element</span><span class="si">}</span><span class="s1">'</span>
    <span class="k">elif</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">element</span><span class="si">}</span><span class="s1">+</span><span class="si">{</span><span class="n">charge</span><span class="si">}</span><span class="s1">'</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">element</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">charge</span><span class="p">)</span><span class="si">}</span><span class="s1">'</span></div>


<div class="viewcode-block" id="SUBQPair"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.SUBQPair">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">SUBQPair</span><span class="p">(</span><span class="n">Endmember</span><span class="p">):</span>
    <span class="n">stoichiometry_quadruplet</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">zeta</span><span class="p">:</span> <span class="nb">float</span>

<div class="viewcode-block" id="SUBQPair.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.SUBQPair.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="c1"># Here the constituent array should be the pair name using the corrected</span>
        <span class="c1"># names, i.e. CU1.0CL1.0</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span>
            <span class="s1">'MQMG'</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">,</span> <span class="n">param_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">param</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">(</span><span class="n">gibbs_coefficient_idxs</span><span class="p">),</span> <span class="n">zeta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="p">,</span>
            <span class="n">stoichiometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stoichiometry_quadruplet</span><span class="p">,</span>
            <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span></div></div>


<div class="viewcode-block" id="SUBQQuadrupletCoordinations"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.SUBQQuadrupletCoordinations">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">SUBQQuadrupletCoordinations</span><span class="p">:</span>
    <span class="n">quadruplet_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>  <span class="c1"># exactly four</span>
    <span class="n">quadruplet_coordinations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>  <span class="c1"># exactly four</span>

<div class="viewcode-block" id="SUBQQuadrupletCoordinations.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.SUBQQuadrupletCoordinations.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">As</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Xs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">"""Add a Z_i_AB:XY parameter for each species defined in the quadruplet"""</span>
        <span class="n">linear_species</span> <span class="o">=</span> <span class="p">[</span><span class="s1">''</span><span class="p">]</span> <span class="o">+</span> <span class="n">As</span> <span class="o">+</span> <span class="n">Xs</span>  <span class="c1"># the leading '' element pads for one-indexed quadruplet_idxs</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">linear_species</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadruplet_idxs</span><span class="p">)</span>
        <span class="n">Z_A</span><span class="p">,</span> <span class="n">Z_B</span><span class="p">,</span> <span class="n">Z_X</span><span class="p">,</span> <span class="n">Z_Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadruplet_coordinations</span>
        <span class="c1"># Constituents and coordinations need to be canonically sorted (within each sublattice)</span>
        <span class="n">constituent_array</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Should be split by sublattice, List[List[float]]</span>
        <span class="n">coordinations</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Should be "linear", List[float]</span>
        <span class="k">for</span> <span class="n">const_subl</span><span class="p">,</span> <span class="n">coord_subl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]],</span> <span class="p">[[</span><span class="n">Z_A</span><span class="p">,</span> <span class="n">Z_B</span><span class="p">],</span> <span class="p">[</span><span class="n">Z_X</span><span class="p">,</span> <span class="n">Z_Y</span><span class="p">]]):</span>
            <span class="n">sorted_const</span><span class="p">,</span> <span class="n">sorted_coord</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="n">const</span><span class="p">,</span> <span class="n">coord</span><span class="p">)</span> <span class="k">for</span> <span class="n">const</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">const_subl</span><span class="p">,</span> <span class="n">coord_subl</span><span class="p">))])</span>
            <span class="n">constituent_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sorted_const</span><span class="p">))</span>
            <span class="n">coordinations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sorted_coord</span><span class="p">)</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span>
            <span class="s2">"MQMZ"</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">,</span> <span class="n">param_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">coordinations</span><span class="o">=</span><span class="n">coordinations</span><span class="p">,</span> <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span></div></div>


<div class="viewcode-block" id="SUBQExcessQuadruplet"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.SUBQExcessQuadruplet">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">SUBQExcessQuadruplet</span><span class="p">:</span>
    <span class="n">mixing_type</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">mixing_code</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># G, Q, B, or R</span>
    <span class="n">mixing_const</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>  <span class="c1"># exactly four</span>
    <span class="n">mixing_exponents</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>  <span class="c1"># exactly four</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>  <span class="c1"># exactly twelve</span>
    <span class="n">additional_cation_mixing_const</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">additional_anion_mixing_const</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">excess_coeffs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<div class="viewcode-block" id="SUBQExcessQuadruplet.expr"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.SUBQExcessQuadruplet.expr">[docs]</a>    <span class="k">def</span> <span class="nf">expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">"""Return an expression for the energy in this temperature interval"""</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="c1"># Add fixed energy terms</span>
        <span class="n">energy</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">C</span><span class="o">*</span><span class="n">EXCESS_TERMS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">C</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excess_coeffs</span><span class="p">,</span> <span class="n">indices</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">energy</span></div>

<div class="viewcode-block" id="SUBQExcessQuadruplet.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.SUBQExcessQuadruplet.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">As</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Xs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">excess_coeff_indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">linear_species</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">As</span> <span class="o">+</span> <span class="n">Xs</span>  <span class="c1"># the leading '' element pads for one-indexed quadruplet_idxs</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">linear_species</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mixing_const</span><span class="p">)</span>
        <span class="n">constituent_array</span> <span class="o">=</span> <span class="p">[[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">],</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">]]</span>
        <span class="n">mixing_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mixing_code</span>
        <span class="n">exponents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mixing_exponents</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">(</span><span class="n">excess_coeff_indices</span><span class="p">)</span>

        <span class="n">addtl_cation_mixing_const</span> <span class="o">=</span> <span class="n">linear_species</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">additional_cation_mixing_const</span><span class="p">]</span>
        <span class="n">addtl_anion_mixing_const</span> <span class="o">=</span> <span class="n">linear_species</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">additional_anion_mixing_const</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">addtl_cation_mixing_const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">addtl_anion_mixing_const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Having a cation _and_ anion as additional mixing constituents is not allowed. Got </span><span class="si">{</span><span class="n">addtl_cation_mixing_const</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">addtl_anion_mixing_const</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">phase_name</span><span class="si">}</span><span class="s2"> and quadruplet </span><span class="si">{</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="si">}</span><span class="s2">."</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">addtl_cation_mixing_const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">addtl_mixing_const</span> <span class="o">=</span> <span class="n">addtl_cation_mixing_const</span>
            <span class="n">addtl_mixing_expon</span> <span class="o">=</span> <span class="n">exponents</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">addtl_anion_mixing_const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">addtl_mixing_const</span> <span class="o">=</span> <span class="n">addtl_anion_mixing_const</span>
            <span class="n">addtl_mixing_expon</span> <span class="o">=</span> <span class="n">exponents</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">addtl_mixing_const</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">addtl_mixing_expon</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">species_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dbf</span><span class="o">.</span><span class="n">species</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">addtl_mixing_const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additional_mixing_constituent</span> <span class="o">=</span> <span class="n">species_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">addtl_mixing_const</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">Species</span><span class="p">(</span><span class="n">addtl_mixing_const</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">additional_mixing_constituent</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">Species</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">dbf</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span>
            <span class="s2">"MQMX"</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">,</span> <span class="n">param_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="n">expr</span><span class="p">,</span>
            <span class="n">mixing_code</span><span class="o">=</span><span class="n">mixing_code</span><span class="p">,</span> <span class="n">exponents</span><span class="o">=</span><span class="n">exponents</span><span class="p">,</span>
            <span class="n">additional_mixing_constituent</span><span class="o">=</span><span class="n">additional_mixing_constituent</span><span class="p">,</span>
            <span class="n">additional_mixing_exponent</span><span class="o">=</span><span class="n">addtl_mixing_expon</span><span class="p">,</span>
            <span class="n">force_insert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_species</span><span class="p">(</span><span class="n">el_chg</span><span class="p">):</span>
    <span class="n">el</span><span class="p">,</span> <span class="n">chg</span> <span class="o">=</span> <span class="n">el_chg</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">rename_element_charge</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">chg</span><span class="p">)</span>
    <span class="n">constituents</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">parse_chemical_formula</span><span class="p">(</span><span class="n">el</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">Species</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">constituents</span><span class="o">=</span><span class="n">constituents</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="n">chg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_process_chemical_group_override_string</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Parse strings for special MQMQA (SUBG/SUBQ) parameters that indicate Kohler/Toop</span>
<span class="sd">    mixing special cases that are not expressed in the specified chemical groups</span>
<span class="sd">    ("chemical group overrides").</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; overrides = _process_chemical_group_override_string('3 1 4T3 3 1K 3 4T4 1 4 5')</span>
<span class="sd">    &gt;&gt;&gt; assert overrides['ternary_element_indices'] == [3, 1, 4]</span>
<span class="sd">    &gt;&gt;&gt; assert [bx['interaction_type'] for bx in overrides['binary_interactions']] == ['T', 'K', 'T']</span>
<span class="sd">    &gt;&gt;&gt; assert [bx.get('toop_element_index') for bx in overrides['binary_interactions']] == [3, None, 4]</span>
<span class="sd">    &gt;&gt;&gt; assert [bx['interacting_element_indices'] for bx in overrides['binary_interactions']] == [[3, 1], [3, 4], [1, 4]]</span>
<span class="sd">    &gt;&gt;&gt; assert overrides['non_mixing_element_index'] == 5</span>

<span class="sd">    """</span>
    <span class="n">override_tokens</span> <span class="o">=</span> <span class="n">TokenParser</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"K"</span><span class="p">,</span> <span class="s2">" K"</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"T"</span><span class="p">,</span> <span class="s2">" T "</span><span class="p">))</span>
    <span class="n">override_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ternary_element_indices</span> <span class="o">=</span> <span class="n">override_tokens</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">override_dict</span><span class="p">[</span><span class="s2">"ternary_element_indices"</span><span class="p">]</span> <span class="o">=</span> <span class="n">ternary_element_indices</span>
    <span class="n">override_dict</span><span class="p">[</span><span class="s2">"binary_interactions"</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="c1"># Parse the extrapolation type of each binary interaction in the ternary,</span>
        <span class="c1"># with the appropriate metadata according to the interaction type</span>
        <span class="n">binary_interaction_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">interaction_type</span> <span class="o">=</span> <span class="n">override_tokens</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="n">binary_interaction_dict</span><span class="p">[</span><span class="s2">"interaction_type"</span><span class="p">]</span> <span class="o">=</span> <span class="n">interaction_type</span>
        <span class="k">if</span> <span class="n">interaction_type</span> <span class="o">==</span> <span class="s2">"K"</span><span class="p">:</span>
            <span class="c1"># Kohler, no special handling</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">interaction_type</span> <span class="o">==</span> <span class="s2">"T"</span><span class="p">:</span>
            <span class="c1"># Toop, parse which element is the odd-element-out</span>
            <span class="n">binary_interaction_dict</span><span class="p">[</span><span class="s2">"toop_element_index"</span><span class="p">]</span> <span class="o">=</span> <span class="n">override_tokens</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Unknown extrapolation type </span><span class="si">{</span><span class="n">interaction_type</span><span class="si">}</span><span class="s2"> encountered while processing override string."</span><span class="p">)</span>
        <span class="n">binary_interaction_dict</span><span class="p">[</span><span class="s2">"interacting_element_indices"</span><span class="p">]</span> <span class="o">=</span> <span class="n">override_tokens</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">override_dict</span><span class="p">[</span><span class="s2">"binary_interactions"</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">binary_interaction_dict</span><span class="p">)</span>
    <span class="n">override_dict</span><span class="p">[</span><span class="s2">"non_mixing_element_index"</span><span class="p">]</span> <span class="o">=</span> <span class="n">override_tokens</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">override_dict</span>


<div class="viewcode-block" id="Phase_SUBQ"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Phase_SUBQ">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Phase_SUBQ</span><span class="p">(</span><span class="n">PhaseBase</span><span class="p">):</span>
    <span class="n">num_pairs</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">num_quadruplets</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">num_subl_1_const</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">num_subl_2_const</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">subl_1_const</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">subl_2_const</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">subl_1_charges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">subl_1_chemical_groups</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">subl_2_charges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">subl_2_chemical_groups</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">subl_const_idx_pairs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
    <span class="n">quadruplets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SUBQQuadrupletCoordinations</span><span class="p">]</span>
    <span class="n">excess_parameters</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">SUBQExcessQuadruplet</span><span class="p">]</span>
    <span class="n">chemical_group_overrides</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

<div class="viewcode-block" id="Phase_SUBQ.insert"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Phase_SUBQ.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">pure_elements</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">excess_coefficient_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="c1"># First: get the pair and quadruplet species added to the database:</span>
        <span class="c1"># Here we rename the species names according to their charges, to avoid creating duplicate pairs/quadruplets</span>
        <span class="n">cation_el_chg_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subl_1_const</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subl_1_charges</span><span class="p">))</span>
        <span class="c1"># anion charges are given as positive values, but should be negative in</span>
        <span class="c1"># order to make the species entered in the expected way (`CL-1`).</span>
        <span class="n">anion_el_chg_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subl_2_const</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subl_2_charges</span><span class="p">]))</span>
        <span class="c1"># pycalphad usually uses Species to differentiate charged species, for</span>
        <span class="c1"># example Species('CU', charge=1) vs. Species('CU', charge=2). In the</span>
        <span class="c1"># implementation of the model, we will use Speices to refer to a</span>
        <span class="c1"># quadruplet which may have both CU+1 and CU+2 species inside, so we</span>
        <span class="c1"># need to add an additional qualifier that mangles the name of the</span>
        <span class="c1"># elements in the species so that we can clearly differentiate the</span>
        <span class="c1"># (CU+1 CU+1):(XY) quadruplet from the (CU+2 CU+2):(XY) quadruplet. We</span>
        <span class="c1"># do that by adding the charge to the name (without +/-), i.e. CU_1 or</span>
        <span class="c1"># CU_1.0. This mangling frees us from worrying about Species name</span>
        <span class="c1"># collisions within the Database.</span>
        <span class="n">cations</span> <span class="o">=</span> <span class="p">[</span><span class="n">rename_element_charge</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">chg</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">chg</span> <span class="ow">in</span> <span class="n">cation_el_chg_pairs</span><span class="p">]</span>
        <span class="n">anions</span> <span class="o">=</span> <span class="p">[</span><span class="n">rename_element_charge</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">chg</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">chg</span> <span class="ow">in</span> <span class="n">anion_el_chg_pairs</span><span class="p">]</span>
        <span class="c1"># Add the (renamed) species to the database so the phase constituents can be added</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">species</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_species</span><span class="p">,</span> <span class="n">cation_el_chg_pairs</span><span class="p">))</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">species</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_species</span><span class="p">,</span> <span class="n">anion_el_chg_pairs</span><span class="p">))</span>

        <span class="c1"># Second: add the phase and phase constituents</span>
        <span class="n">model_hints</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">"mqmqa"</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">"type"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_type</span><span class="p">,</span>
                <span class="s2">"chemical_groups"</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">"cations"</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_species</span><span class="p">,</span> <span class="n">cation_el_chg_pairs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">subl_1_chemical_groups</span><span class="p">)),</span>
                    <span class="s2">"anions"</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_species</span><span class="p">,</span> <span class="n">anion_el_chg_pairs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">subl_2_chemical_groups</span><span class="p">)),</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_phase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">model_hints</span><span class="p">,</span> <span class="n">sublattices</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">])</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_structure_entry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">)</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">add_phase_constituents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="p">[</span><span class="n">cations</span><span class="p">,</span> <span class="n">anions</span><span class="p">])</span>

        <span class="c1"># Third: add the endmember (pair) Gibbs energies</span>
        <span class="n">num_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">cations</span><span class="p">,</span> <span class="n">anions</span><span class="p">)))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_pairs</span>

        <span class="c1"># Endmember pairs came in order of the specified subl_const_idx_pairs labels.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">endmember</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subl_const_idx_pairs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endmembers</span><span class="p">):</span>
            <span class="n">endmember</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="p">[[</span><span class="n">cations</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">anions</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]]],</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">)</span>

        <span class="c1"># Fourth: add parameters for coordinations</span>
        <span class="k">for</span> <span class="n">quadruplet</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadruplets</span><span class="p">:</span>
            <span class="n">quadruplet</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">cations</span><span class="p">,</span> <span class="n">anions</span><span class="p">)</span>

        <span class="c1"># Fifth: add excess parameters</span>
        <span class="k">for</span> <span class="n">excess_param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excess_parameters</span><span class="p">:</span>
            <span class="n">excess_param</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">cations</span><span class="p">,</span> <span class="n">anions</span><span class="p">,</span> <span class="n">excess_coefficient_idxs</span><span class="p">)</span>

        <span class="c1"># Process chemical group overrides - for now we simply warn with the affected species if any overrides are detected.</span>
        <span class="k">for</span> <span class="n">override_string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_group_overrides</span><span class="p">:</span>
            <span class="n">override_dict</span> <span class="o">=</span> <span class="n">_process_chemical_group_override_string</span><span class="p">(</span><span class="n">override_string</span><span class="p">)</span>
            <span class="n">overriden_species_indices</span> <span class="o">=</span> <span class="n">override_dict</span><span class="p">[</span><span class="s2">"ternary_element_indices"</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">override_dict</span><span class="p">[</span><span class="s2">"non_mixing_element_index"</span><span class="p">]]</span>
            <span class="n">dummy_xs</span> <span class="o">=</span> <span class="n">ExcessBase</span><span class="p">(</span><span class="n">overriden_species_indices</span><span class="p">)</span>
            <span class="n">override_constituents</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">subl_constituents</span> <span class="ow">in</span> <span class="n">dummy_xs</span><span class="o">.</span><span class="n">constituent_array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">subl_1_const</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">subl_2_const</span><span class="p">]):</span>
                <span class="n">override_constituents</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subl_constituents</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Phase </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_name</span><span class="si">}</span><span class="s2"> overrides the ternary extrapolation models for the system </span><span class="si">{</span><span class="n">override_constituents</span><span class="si">}</span><span class="s2">. Use caution as extrapolated energies may be incorrect."</span><span class="p">)</span></div></div>


<span class="c1"># TODO: not yet supported</span>
<div class="viewcode-block" id="Phase_RealGas"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Phase_RealGas">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Phase_RealGas</span><span class="p">(</span><span class="n">PhaseBase</span><span class="p">):</span>
    <span class="n">endmembers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EndmemberRealGas</span><span class="p">]</span></div>


<span class="c1"># TODO: not yet supported</span>
<div class="viewcode-block" id="Phase_Aqueous"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.Phase_Aqueous">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Phase_Aqueous</span><span class="p">(</span><span class="n">PhaseBase</span><span class="p">):</span>
    <span class="n">endmembers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EndmemberAqueous</span><span class="p">]</span></div>


<div class="viewcode-block" id="tokenize"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.tokenize">[docs]</a><span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">startline</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">force_upper</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">force_upper</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TokenParser</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">instring</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()[</span><span class="n">startline</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TokenParser</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">instring</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()[</span><span class="n">startline</span><span class="p">:]))</span></div>


<div class="viewcode-block" id="parse_header"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_header">[docs]</a><span class="k">def</span> <span class="nf">parse_header</span><span class="p">(</span><span class="n">toks</span><span class="p">:</span> <span class="n">TokenParser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Header</span><span class="p">:</span>
    <span class="n">num_pure_elements</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">num_soln_phases</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">list_soln_species_count</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_soln_phases</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">num_stoich_phases</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">pure_elements</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_pure_elements</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">pure_elements_mass</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_pure_elements</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">num_gibbs_coeffs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">gibbs_coefficient_idxs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">num_excess_coeffs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">excess_coefficient_idxs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_excess_coeffs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">Header</span><span class="p">(</span><span class="n">list_soln_species_count</span><span class="p">,</span> <span class="n">num_stoich_phases</span><span class="p">,</span> <span class="n">pure_elements</span><span class="p">,</span> <span class="n">pure_elements_mass</span><span class="p">,</span> <span class="n">gibbs_coefficient_idxs</span><span class="p">,</span> <span class="n">excess_coefficient_idxs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">header</span></div>


<div class="viewcode-block" id="parse_additional_terms"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_additional_terms">[docs]</a><span class="k">def</span> <span class="nf">parse_additional_terms</span><span class="p">(</span><span class="n">toks</span><span class="p">:</span> <span class="n">TokenParser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AdditionalCoefficientPair</span><span class="p">]:</span>
    <span class="n">num_additional_terms</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">AdditionalCoefficientPair</span><span class="p">(</span><span class="o">*</span><span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_additional_terms</span><span class="p">)]</span></div>


<div class="viewcode-block" id="parse_PTVm_terms"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_PTVm_terms">[docs]</a><span class="k">def</span> <span class="nf">parse_PTVm_terms</span><span class="p">(</span><span class="n">toks</span><span class="p">:</span> <span class="n">TokenParser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PTVmTerms</span><span class="p">:</span>
    <span class="c1"># parse molar volume terms, there seem to always be 11 terms (at least in the one file I have)</span>
    <span class="k">return</span> <span class="n">PTVmTerms</span><span class="p">(</span><span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span></div>


<div class="viewcode-block" id="parse_interval_Gibbs"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_interval_Gibbs">[docs]</a><span class="k">def</span> <span class="nf">parse_interval_Gibbs</span><span class="p">(</span><span class="n">toks</span><span class="p">:</span> <span class="n">TokenParser</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">has_additional_terms</span><span class="p">,</span> <span class="n">has_PTVm_terms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalG</span><span class="p">:</span>
    <span class="n">temperature_max</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">additional_coeff_pairs</span> <span class="o">=</span> <span class="n">parse_additional_terms</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_additional_terms</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">PTVm_terms</span> <span class="o">=</span> <span class="n">parse_PTVm_terms</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_PTVm_terms</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">IntervalG</span><span class="p">(</span><span class="n">temperature_max</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">additional_coeff_pairs</span><span class="p">,</span> <span class="n">PTVm_terms</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_interval_heat_capacity"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_interval_heat_capacity">[docs]</a><span class="k">def</span> <span class="nf">parse_interval_heat_capacity</span><span class="p">(</span><span class="n">toks</span><span class="p">:</span> <span class="n">TokenParser</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">H298</span><span class="p">,</span> <span class="n">S298</span><span class="p">,</span> <span class="n">has_H_trans</span><span class="p">,</span> <span class="n">has_additional_terms</span><span class="p">,</span> <span class="n">has_PTVm_terms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IntervalCP</span><span class="p">:</span>
    <span class="c1"># 6 coefficients are required</span>
    <span class="k">assert</span> <span class="n">num_gibbs_coeffs</span> <span class="o">==</span> <span class="mi">6</span>
    <span class="k">if</span> <span class="n">has_H_trans</span><span class="p">:</span>
        <span class="n">H_trans</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">H_trans</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># 0.0 will be added to the first (or only) interval</span>
    <span class="n">temperature_max</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">CP_coefficients</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">additional_coeff_pairs</span> <span class="o">=</span> <span class="n">parse_additional_terms</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_additional_terms</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">PTVm_terms</span> <span class="o">=</span> <span class="n">parse_PTVm_terms</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_PTVm_terms</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">IntervalCP</span><span class="p">(</span><span class="n">temperature_max</span><span class="p">,</span> <span class="n">H298</span><span class="p">,</span> <span class="n">S298</span><span class="p">,</span> <span class="n">CP_coefficients</span><span class="p">,</span> <span class="n">H_trans</span><span class="p">,</span> <span class="n">additional_coeff_pairs</span><span class="p">,</span> <span class="n">PTVm_terms</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_endmember"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_endmember">[docs]</a><span class="k">def</span> <span class="nf">parse_endmember</span><span class="p">(</span><span class="n">toks</span><span class="p">:</span> <span class="n">TokenParser</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">is_stoichiometric</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">species_name</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">toks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'#'</span><span class="p">:</span>
        <span class="c1"># special case for stoichiometric phases, this is a dummy species, skip it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">gibbs_eq_type</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">TokenParserError</span><span class="p">:</span>
        <span class="c1"># There may be two floats that come after the species name on the same</span>
        <span class="c1"># line. The meaning is not yet clear, but they are often zero. If they</span>
        <span class="c1"># are zero, we will throw them away. This drops into some private APIs</span>
        <span class="c1"># for TokenParser until there's another way to handle these values.</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f1</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TokenParserError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Non-zero values are not yet supported after species </span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">. Got </span><span class="si">{</span><span class="n">f1</span><span class="si">}</span><span class="s2"> at line number </span><span class="si">{</span><span class="n">toks</span><span class="o">.</span><span class="n">_line_number</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2"> for line:</span><span class="se">\n</span><span class="s2">    </span><span class="si">{</span><span class="n">toks</span><span class="o">.</span><span class="n">_current_line</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">f2</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TokenParserError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Non-zero values are not yet supported after species </span><span class="si">{</span><span class="n">species_name</span><span class="si">}</span><span class="s2">. Got </span><span class="si">{</span><span class="n">f2</span><span class="si">}</span><span class="s2"> at line number </span><span class="si">{</span><span class="n">toks</span><span class="o">.</span><span class="n">_line_number</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2"> for line:</span><span class="se">\n</span><span class="s2">    </span><span class="si">{</span><span class="n">toks</span><span class="o">.</span><span class="n">_current_line</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="n">gibbs_eq_type</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># Determine how to parse the type of thermodynamic option</span>
    <span class="n">has_magnetic</span> <span class="o">=</span> <span class="n">gibbs_eq_type</span> <span class="o">&gt;</span> <span class="mi">12</span>
    <span class="n">gibbs_eq_type_reduced</span> <span class="o">=</span> <span class="p">(</span><span class="n">gibbs_eq_type</span> <span class="o">-</span> <span class="mi">12</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_magnetic</span> <span class="k">else</span> <span class="n">gibbs_eq_type</span>
    <span class="n">is_gibbs_energy_interval</span> <span class="o">=</span> <span class="n">gibbs_eq_type_reduced</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">is_heat_capacity_interval</span> <span class="o">=</span> <span class="n">gibbs_eq_type_reduced</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">has_additional_terms</span> <span class="o">=</span> <span class="n">gibbs_eq_type_reduced</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">has_constant_Vm_terms</span> <span class="o">=</span> <span class="n">gibbs_eq_type_reduced</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span>
    <span class="n">has_PTVm_terms</span> <span class="o">=</span> <span class="n">gibbs_eq_type_reduced</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">num_intervals</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">stoichiometry_pure_elements</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_pure_elements</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">has_constant_Vm_terms</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Constant molar volume equations (thermodynamic data options (2, 5, 8, 11)) are not supported yet."</span><span class="p">)</span>
    <span class="c1"># Piecewise endmember energy intervals</span>
    <span class="k">if</span> <span class="n">is_gibbs_energy_interval</span><span class="p">:</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_interval_Gibbs</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">has_additional_terms</span><span class="p">,</span> <span class="n">has_PTVm_terms</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_intervals</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">is_heat_capacity_interval</span><span class="p">:</span>
        <span class="n">H298</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">S298</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># parse the first without H_trans, then parse the rest</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_interval_heat_capacity</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">H298</span><span class="p">,</span> <span class="n">S298</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">has_additional_terms</span><span class="p">,</span> <span class="n">has_PTVm_terms</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_intervals</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parse_interval_heat_capacity</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">H298</span><span class="p">,</span> <span class="n">S298</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">has_additional_terms</span><span class="p">,</span> <span class="n">has_PTVm_terms</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Unknown thermodynamic data option type </span><span class="si">{</span><span class="n">gibbs_eq_type</span><span class="si">}</span><span class="s2">. A number in [1, 24]."</span><span class="p">)</span>
    <span class="c1"># magnetic terms</span>
    <span class="k">if</span> <span class="n">has_magnetic</span><span class="p">:</span>
        <span class="n">curie_temperature</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">magnetic_moment</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EndmemberMagnetic</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">gibbs_eq_type</span><span class="p">,</span> <span class="n">stoichiometry_pure_elements</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">curie_temperature</span><span class="p">,</span> <span class="n">magnetic_moment</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Endmember</span><span class="p">(</span><span class="n">species_name</span><span class="p">,</span> <span class="n">gibbs_eq_type</span><span class="p">,</span> <span class="n">stoichiometry_pure_elements</span><span class="p">,</span> <span class="n">intervals</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_endmember_qkto"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_endmember_qkto">[docs]</a><span class="k">def</span> <span class="nf">parse_endmember_qkto</span><span class="p">(</span><span class="n">toks</span><span class="p">:</span> <span class="n">TokenParser</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="c1"># add an extra "pure element" to parse the charge</span>
    <span class="n">em</span> <span class="o">=</span> <span class="n">parse_endmember</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">)</span>
    <span class="n">stoichiometric_factor</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">chemical_group</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">EndmemberQKTO</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">species_name</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">gibbs_eq_type</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">stoichiometry_pure_elements</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">intervals</span><span class="p">,</span> <span class="n">stoichiometric_factor</span><span class="p">,</span> <span class="n">chemical_group</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_endmember_aqueous"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_endmember_aqueous">[docs]</a><span class="k">def</span> <span class="nf">parse_endmember_aqueous</span><span class="p">(</span><span class="n">toks</span><span class="p">:</span> <span class="n">TokenParser</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="c1"># add an extra "pure element" to parse the charge</span>
    <span class="n">em</span> <span class="o">=</span> <span class="n">parse_endmember</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">EndmemberAqueous</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">species_name</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">gibbs_eq_type</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">stoichiometry_pure_elements</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">em</span><span class="o">.</span><span class="n">intervals</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">stoichiometry_pure_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="parse_endmember_subq"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_endmember_subq">[docs]</a><span class="k">def</span> <span class="nf">parse_endmember_subq</span><span class="p">(</span><span class="n">toks</span><span class="p">:</span> <span class="n">TokenParser</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">zeta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">em</span> <span class="o">=</span> <span class="n">parse_endmember</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">)</span>
    <span class="c1"># The first two entries are the stoichiometry of the pair (the cation and anion). It's unclear to what the last three are for.</span>
    <span class="n">stoichiometry_quadruplet</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zeta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is SUBQ we need to parse it. If zeta is passed, that means we're in SUBG mode</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SUBQPair</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">species_name</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">gibbs_eq_type</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">stoichiometry_pure_elements</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">intervals</span><span class="p">,</span> <span class="n">stoichiometry_quadruplet</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_quadruplet"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_quadruplet">[docs]</a><span class="k">def</span> <span class="nf">parse_quadruplet</span><span class="p">(</span><span class="n">toks</span><span class="p">):</span>
    <span class="n">quad_idx</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">quad_coords</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SUBQQuadrupletCoordinations</span><span class="p">(</span><span class="n">quad_idx</span><span class="p">,</span> <span class="n">quad_coords</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_subq_excess"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_subq_excess">[docs]</a><span class="k">def</span> <span class="nf">parse_subq_excess</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">mixing_type</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">):</span>
    <span class="n">mixing_code</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">mixing_const</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">mixing_exponents</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>  <span class="c1"># TODO: not sure what this metadata is - could it be more parameters? They are usually all zeros.</span>
    <span class="n">additional_cation_mixing_const</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">additional_anion_mixing_exponent</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">excess_coeffs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_excess_coeffs</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SUBQExcessQuadruplet</span><span class="p">(</span><span class="n">mixing_type</span><span class="p">,</span> <span class="n">mixing_code</span><span class="p">,</span> <span class="n">mixing_const</span><span class="p">,</span> <span class="n">mixing_exponents</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">additional_cation_mixing_const</span><span class="p">,</span> <span class="n">additional_anion_mixing_exponent</span><span class="p">,</span> <span class="n">excess_coeffs</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_phase_subq"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_phase_subq">[docs]</a><span class="k">def</span> <span class="nf">parse_phase_subq</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">phase_type</span> <span class="o">==</span> <span class="s1">'SUBG'</span><span class="p">:</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">num_pairs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">num_quadruplets</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">endmembers</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_endmember_subq</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">zeta</span><span class="o">=</span><span class="n">zeta</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pairs</span><span class="p">)]</span>
    <span class="n">num_subl_1_const</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">num_subl_2_const</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">subl_1_const</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl_1_const</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">subl_2_const</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl_2_const</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">subl_1_charges</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl_1_const</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">subl_1_chemical_groups</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl_1_const</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">subl_2_charges</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl_2_const</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">subl_2_chemical_groups</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl_2_const</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">subl_1_pair_idx</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl_1_const</span><span class="o">*</span><span class="n">num_subl_2_const</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">subl_2_pair_idx</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl_1_const</span><span class="o">*</span><span class="n">num_subl_2_const</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">subl_const_idx_pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s1i</span><span class="p">,</span> <span class="n">s2i</span><span class="p">)</span> <span class="k">for</span> <span class="n">s1i</span><span class="p">,</span> <span class="n">s2i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">subl_1_pair_idx</span><span class="p">,</span> <span class="n">subl_2_pair_idx</span><span class="p">)]</span>
    <span class="n">quadruplets</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_quadruplet</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_quadruplets</span><span class="p">)]</span>
    <span class="n">excess_parameters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chemical_group_overrides</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">mixing_type</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mixing_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">mixing_type</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># For mixing type -N, there are N*10 tokens.</span>
            <span class="c1"># The tokens look something like `1 2 3K 1 2K 1 3K 2 3 6`</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">mixing_type</span><span class="p">):</span>
                <span class="c1"># For each entry, simply parse the whole string</span>
                <span class="n">chemical_group_overrides</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">" "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">str</span><span class="p">)))</span>
            <span class="k">break</span>
        <span class="n">excess_parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parse_subq_excess</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">mixing_type</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Phase_SUBQ</span><span class="p">(</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">endmembers</span><span class="p">,</span> <span class="n">num_pairs</span><span class="p">,</span> <span class="n">num_quadruplets</span><span class="p">,</span> <span class="n">num_subl_1_const</span><span class="p">,</span> <span class="n">num_subl_2_const</span><span class="p">,</span> <span class="n">subl_1_const</span><span class="p">,</span> <span class="n">subl_2_const</span><span class="p">,</span> <span class="n">subl_1_charges</span><span class="p">,</span> <span class="n">subl_1_chemical_groups</span><span class="p">,</span> <span class="n">subl_2_charges</span><span class="p">,</span> <span class="n">subl_2_chemical_groups</span><span class="p">,</span> <span class="n">subl_const_idx_pairs</span><span class="p">,</span> <span class="n">quadruplets</span><span class="p">,</span> <span class="n">excess_parameters</span><span class="p">,</span> <span class="n">chemical_group_overrides</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_excess_magnetic_parameters"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_excess_magnetic_parameters">[docs]</a><span class="k">def</span> <span class="nf">parse_excess_magnetic_parameters</span><span class="p">(</span><span class="n">toks</span><span class="p">):</span>
    <span class="n">excess_terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">num_interacting_species</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_interacting_species</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">interacting_species_idxs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_interacting_species</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">num_terms</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">parameter_order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_terms</span><span class="p">):</span>
            <span class="n">curie_temperature</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">magnetic_moment</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">excess_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExcessRKMMagnetic</span><span class="p">(</span><span class="n">interacting_species_idxs</span><span class="p">,</span> <span class="n">parameter_order</span><span class="p">,</span> <span class="n">curie_temperature</span><span class="p">,</span> <span class="n">magnetic_moment</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">excess_terms</span></div>


<div class="viewcode-block" id="parse_excess_parameters"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_excess_parameters">[docs]</a><span class="k">def</span> <span class="nf">parse_excess_parameters</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">):</span>
    <span class="n">excess_terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">num_interacting_species</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_interacting_species</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">interacting_species_idxs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_interacting_species</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">num_terms</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">parameter_order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_terms</span><span class="p">):</span>
            <span class="n">excess_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExcessRKM</span><span class="p">(</span><span class="n">interacting_species_idxs</span><span class="p">,</span> <span class="n">parameter_order</span><span class="p">,</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_excess_coeffs</span><span class="p">,</span> <span class="nb">float</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">excess_terms</span></div>


<div class="viewcode-block" id="parse_excess_parameters_pitz"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_excess_parameters_pitz">[docs]</a><span class="k">def</span> <span class="nf">parse_excess_parameters_pitz</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">):</span>
    <span class="n">excess_terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">num_interacting_species</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_interacting_species</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># there are always 3 ints, regardless of the above "number of interacting species", if the number of interactings species is 2, we'll just throw the third number away for now</span>
        <span class="k">if</span> <span class="n">num_interacting_species</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">interacting_species_idxs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_interacting_species</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num_interacting_species</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">interacting_species_idxs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_interacting_species</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Invalid number of interacting species for Pitzer model, got </span><span class="si">{</span><span class="n">num_interacting_species</span><span class="si">}</span><span class="s2"> (expected 2 or 3)."</span><span class="p">)</span>
        <span class="n">parameter_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">excess_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExcessRKM</span><span class="p">(</span><span class="n">interacting_species_idxs</span><span class="p">,</span> <span class="n">parameter_order</span><span class="p">,</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_excess_coeffs</span><span class="p">,</span> <span class="nb">float</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">excess_terms</span></div>


<div class="viewcode-block" id="parse_excess_qkto"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_excess_qkto">[docs]</a><span class="k">def</span> <span class="nf">parse_excess_qkto</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">):</span>
    <span class="n">excess_terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">num_interacting_species</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_interacting_species</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">interacting_species_idxs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_interacting_species</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">exponents</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_interacting_species</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_excess_coeffs</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">excess_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExcessQKTO</span><span class="p">(</span><span class="n">interacting_species_idxs</span><span class="p">,</span> <span class="n">exponents</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">excess_terms</span></div>


<div class="viewcode-block" id="parse_phase_cef"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_phase_cef">[docs]</a><span class="k">def</span> <span class="nf">parse_phase_cef</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">,</span> <span class="n">num_const</span><span class="p">):</span>
    <span class="n">is_magnetic_phase_type</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">phase_type</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'M'</span>
    <span class="n">sanitized_phase_type</span> <span class="o">=</span> <span class="n">phase_type</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>  <span class="c1"># drop the magnetic contribution, only used for matching later (i.e. SUBLM -&gt; SUBL)</span>
    <span class="k">if</span> <span class="n">is_magnetic_phase_type</span><span class="p">:</span>
        <span class="n">allowed_magnetic_phase_types</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'RKMP'</span><span class="p">,</span> <span class="s1">'QKTO'</span><span class="p">,</span> <span class="s1">'SUBL'</span><span class="p">,</span> <span class="s1">'SUBM'</span><span class="p">,</span> <span class="s1">'SUBG'</span><span class="p">,</span> <span class="s1">'SUBQ'</span><span class="p">,</span> <span class="s1">'WAGN'</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sanitized_phase_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_magnetic_phase_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Magnetic phase type </span><span class="si">{</span><span class="n">phase_type</span><span class="si">}</span><span class="s1"> is only supported for </span><span class="si">{</span><span class="n">allowed_magnetic_phase_types</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
        <span class="n">magnetic_afm_factor</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">magnetic_structure_factor</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">magnetic_afm_factor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">magnetic_structure_factor</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">endmembers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_const</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sanitized_phase_type</span> <span class="o">==</span> <span class="s1">'PITZ'</span><span class="p">:</span>
            <span class="n">endmembers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parse_endmember_aqueous</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">sanitized_phase_type</span> <span class="o">==</span> <span class="s1">'QKTO'</span><span class="p">:</span>
            <span class="n">endmembers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parse_endmember_qkto</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endmembers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parse_endmember</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">))</span>

    <span class="c1"># defining sublattice model</span>
    <span class="k">if</span> <span class="n">sanitized_phase_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'SUBL'</span><span class="p">,):</span>
        <span class="n">num_subl</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">subl_atom_fracs</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="c1"># some phases have number of atoms after a colon in the phase name, e.g. SIGMA:30</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">':'</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">num_atoms</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">phase_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">':'</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_atoms</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">subl_ratios</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_atoms</span><span class="o">*</span><span class="n">subl_frac</span> <span class="k">for</span> <span class="n">subl_frac</span> <span class="ow">in</span> <span class="n">subl_atom_fracs</span><span class="p">]</span>
        <span class="c1"># read the data used to recover the mass, it's redundant and doesn't need to be stored</span>
        <span class="n">subl_constituents</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">constituent_array</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">num_subl_species</span> <span class="ow">in</span> <span class="n">subl_constituents</span><span class="p">:</span>
            <span class="n">constituent_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_subl_species</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
        <span class="n">num_endmembers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">subl_constituents</span><span class="p">))</span>
        <span class="n">endmember_constituent_idxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_subl</span><span class="p">):</span>
            <span class="n">endmember_constituent_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">toks</span><span class="o">.</span><span class="n">parseN</span><span class="p">(</span><span class="n">num_endmembers</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span>
        <span class="c1"># endmember_constituents now is like [[1, 2, 3, 4], [1, 1, 1, 1]] for</span>
        <span class="c1"># a two sublattice phase with (4, 1) constituents</span>
        <span class="c1"># we want to invert this so each endmember is a pair, i.e.</span>
        <span class="c1"># endmember_constituents = [[1, 1], [2, 1], [3, 1], [4, 1]]</span>
        <span class="n">endmember_constituent_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">endmember_constituent_idxs</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">sanitized_phase_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'IDMX'</span><span class="p">,</span> <span class="s1">'RKMP'</span><span class="p">,</span> <span class="s1">'QKTO'</span><span class="p">,</span> <span class="s1">'PITZ'</span><span class="p">):</span>
        <span class="n">subl_ratios</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
        <span class="n">constituent_array</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># implictly defined by the endmembers</span>
        <span class="n">endmember_constituent_idxs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Phase type </span><span class="si">{</span><span class="n">phase_type</span><span class="si">}</span><span class="s2"> does not have method defined for determing the sublattice ratios"</span><span class="p">)</span>

    <span class="c1"># excess terms</span>
    <span class="k">if</span> <span class="n">sanitized_phase_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'IDMX'</span><span class="p">,):</span>
        <span class="c1"># No excess parameters</span>
        <span class="n">excess_parameters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="n">sanitized_phase_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'PITZ'</span><span class="p">,):</span>
        <span class="n">excess_parameters</span> <span class="o">=</span> <span class="n">parse_excess_parameters_pitz</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">sanitized_phase_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'RKMP'</span><span class="p">,</span> <span class="s1">'SUBL'</span><span class="p">):</span>
        <span class="c1"># SUBL will have no excess parameters, but it will have the "0" terminator like it has excess parameters so we can use the excess parameter parsing to process it all the same.</span>
        <span class="n">excess_parameters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">is_magnetic_phase_type</span><span class="p">:</span>
            <span class="n">excess_parameters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">parse_excess_magnetic_parameters</span><span class="p">(</span><span class="n">toks</span><span class="p">))</span>
        <span class="n">excess_parameters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">parse_excess_parameters</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">sanitized_phase_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'QKTO'</span><span class="p">,):</span>
        <span class="n">excess_parameters</span> <span class="o">=</span> <span class="n">parse_excess_qkto</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Phase_CEF</span><span class="p">(</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">endmembers</span><span class="p">,</span> <span class="n">subl_ratios</span><span class="p">,</span> <span class="n">constituent_array</span><span class="p">,</span> <span class="n">endmember_constituent_idxs</span><span class="p">,</span> <span class="n">excess_parameters</span><span class="p">,</span> <span class="n">magnetic_afm_factor</span><span class="o">=</span><span class="n">magnetic_afm_factor</span><span class="p">,</span> <span class="n">magnetic_structure_factor</span><span class="o">=</span><span class="n">magnetic_structure_factor</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_phase_real_gas"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_phase_real_gas">[docs]</a><span class="k">def</span> <span class="nf">parse_phase_real_gas</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">num_const</span><span class="p">):</span>
    <span class="n">endmembers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_const</span><span class="p">):</span>
        <span class="n">em</span> <span class="o">=</span> <span class="n">parse_endmember</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">)</span>
        <span class="n">Tc</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">Pc</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">Vc</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">acentric_factor</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">dipole_moment</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">endmembers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">EndmemberRealGas</span><span class="p">(</span><span class="n">em</span><span class="o">.</span><span class="n">species_name</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">gibbs_eq_type</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">stoichiometry_pure_elements</span><span class="p">,</span> <span class="n">em</span><span class="o">.</span><span class="n">intervals</span><span class="p">,</span> <span class="n">Tc</span><span class="p">,</span> <span class="n">Pc</span><span class="p">,</span> <span class="n">Vc</span><span class="p">,</span> <span class="n">acentric_factor</span><span class="p">,</span> <span class="n">dipole_moment</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Phase_RealGas</span><span class="p">(</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">endmembers</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_phase_aqueous"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_phase_aqueous">[docs]</a><span class="k">def</span> <span class="nf">parse_phase_aqueous</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">num_const</span><span class="p">):</span>
    <span class="n">endmembers</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_endmember_aqueous</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_const</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">Phase_Aqueous</span><span class="p">(</span><span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">endmembers</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_phase"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_phase">[docs]</a><span class="k">def</span> <span class="nf">parse_phase</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">,</span> <span class="n">num_const</span><span class="p">):</span>
    <span class="sd">"""Dispatches to the correct parser depending on the phase type"""</span>
    <span class="n">phase_name</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">phase_type</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">phase_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'SUBQ'</span><span class="p">,</span> <span class="s1">'SUBG'</span><span class="p">):</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">parse_phase_subq</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">phase_type</span> <span class="o">==</span> <span class="s1">'IDVD'</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">parse_phase_real_gas</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">num_const</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">phase_type</span> <span class="o">==</span> <span class="s1">'IDWZ'</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">parse_phase_aqueous</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">num_const</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">phase_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'IDMX'</span><span class="p">,</span> <span class="s1">'RKMP'</span><span class="p">,</span> <span class="s1">'RKMPM'</span><span class="p">,</span> <span class="s1">'QKTO'</span><span class="p">,</span> <span class="s1">'SUBL'</span><span class="p">,</span> <span class="s1">'SUBLM'</span><span class="p">,</span> <span class="s1">'PITZ'</span><span class="p">):</span>
        <span class="c1"># all these phases parse the same</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">parse_phase_cef</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">phase_name</span><span class="p">,</span> <span class="n">phase_type</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">,</span> <span class="n">num_const</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"phase type </span><span class="si">{</span><span class="n">phase_type</span><span class="si">}</span><span class="s2"> not yet supported"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">phase</span></div>


<div class="viewcode-block" id="parse_stoich_phase"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_stoich_phase">[docs]</a><span class="k">def</span> <span class="nf">parse_stoich_phase</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">):</span>
    <span class="n">endmember</span> <span class="o">=</span> <span class="n">parse_endmember</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">is_stoichiometric</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">endmember</span><span class="p">,</span> <span class="n">EndmemberMagnetic</span><span class="p">):</span>
        <span class="n">magnetic_afm_factor</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">magnetic_structure_factor</span> <span class="o">=</span> <span class="n">toks</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">magnetic_afm_factor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">magnetic_structure_factor</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">phase_name</span> <span class="o">=</span> <span class="n">endmember</span><span class="o">.</span><span class="n">species_name</span>
    <span class="k">return</span> <span class="n">Phase_Stoichiometric</span><span class="p">(</span><span class="n">phase_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">endmember</span><span class="p">],</span> <span class="n">magnetic_afm_factor</span><span class="o">=</span><span class="n">magnetic_afm_factor</span><span class="p">,</span> <span class="n">magnetic_structure_factor</span><span class="o">=</span><span class="n">magnetic_structure_factor</span><span class="p">)</span></div>


<div class="viewcode-block" id="parse_cs_dat"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.parse_cs_dat">[docs]</a><span class="k">def</span> <span class="nf">parse_cs_dat</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
    <span class="n">toks</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">startline</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">parse_header</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span>
    <span class="n">num_pure_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">pure_elements</span><span class="p">)</span>
    <span class="n">num_gibbs_coeffs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">gibbs_coefficient_idxs</span><span class="p">)</span>
    <span class="n">num_excess_coeffs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">excess_coefficient_idxs</span><span class="p">)</span>
    <span class="c1"># num_const = 0 is gas phase that isn't present, so skip it</span>
    <span class="n">solution_phases</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_phase</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">,</span> <span class="n">num_excess_coeffs</span><span class="p">,</span> <span class="n">num_const</span><span class="p">)</span> <span class="k">for</span> <span class="n">num_const</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">list_soln_species_count</span> <span class="k">if</span> <span class="n">num_const</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">stoichiometric_phases</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_stoich_phase</span><span class="p">(</span><span class="n">toks</span><span class="p">,</span> <span class="n">num_pure_elements</span><span class="p">,</span> <span class="n">num_gibbs_coeffs</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">num_stoich_phases</span><span class="p">)]</span>
    <span class="c1"># By convention there are sometimes comments at the end that we ignore.</span>
    <span class="c1"># Any remaining lines after the number of prescribed phases and</span>
    <span class="c1"># stoichiometric compounds are not parsed.</span>
    <span class="k">return</span> <span class="n">header</span><span class="p">,</span> <span class="n">solution_phases</span><span class="p">,</span> <span class="n">stoichiometric_phases</span></div>


<div class="viewcode-block" id="read_cs_dat"><a class="viewcode-back" href="../../../api/pycalphad.io.html#pycalphad.io.cs_dat.read_cs_dat">[docs]</a><span class="k">def</span> <span class="nf">read_cs_dat</span><span class="p">(</span><span class="n">dbf</span><span class="p">:</span> <span class="n">Database</span><span class="p">,</span> <span class="n">fd</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Parse a ChemSage DAT file into a pycalphad Database object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dbf : Database</span>
<span class="sd">        A pycalphad Database.</span>
<span class="sd">    fd : file-like</span>
<span class="sd">        File descriptor.</span>
<span class="sd">    """</span>
    <span class="n">header</span><span class="p">,</span> <span class="n">solution_phases</span><span class="p">,</span> <span class="n">stoichiometric_phases</span> <span class="o">=</span> <span class="n">parse_cs_dat</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
    <span class="c1"># add elements and their reference states</span>
    <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">mass</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">pure_elements</span><span class="p">,</span> <span class="n">header</span><span class="o">.</span><span class="n">pure_elements_mass</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">'E('</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">el</span><span class="p">):</span>
            <span class="n">dbf</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
            <span class="n">dbf</span><span class="o">.</span><span class="n">species</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Species</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
            <span class="c1"># add element reference state data</span>
            <span class="n">dbf</span><span class="o">.</span><span class="n">refstates</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">'mass'</span><span class="p">:</span> <span class="n">mass</span><span class="p">,</span>
                <span class="c1"># the following metadata is not given in DAT files,</span>
                <span class="c1"># but is standard for our Database files</span>
                <span class="s1">'phase'</span><span class="p">:</span> <span class="s1">'BLANK'</span><span class="p">,</span>
                <span class="s1">'H298'</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="s1">'S298'</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="p">}</span>
    <span class="c1"># Each phase subclass knows how to insert itself into the database.</span>
    <span class="c1"># The insert method will appropriately insert all endmembers as well.</span>
    <span class="n">processed_phases</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">parsed_phase</span> <span class="ow">in</span> <span class="p">(</span><span class="o">*</span><span class="n">solution_phases</span><span class="p">,</span> <span class="o">*</span><span class="n">stoichiometric_phases</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">parsed_phase</span><span class="o">.</span><span class="n">phase_name</span> <span class="ow">in</span> <span class="n">processed_phases</span><span class="p">:</span>
            <span class="c1"># DAT files allow multiple entries of the same phase to handle</span>
            <span class="c1"># miscibility gaps. We discard the duplicate phase definitions.</span>
            <span class="k">continue</span>
        <span class="n">parsed_phase</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">header</span><span class="o">.</span><span class="n">pure_elements</span><span class="p">,</span> <span class="n">header</span><span class="o">.</span><span class="n">gibbs_coefficient_idxs</span><span class="p">,</span> <span class="n">header</span><span class="o">.</span><span class="n">excess_coefficient_idxs</span><span class="p">)</span>
        <span class="n">processed_phases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parsed_phase</span><span class="o">.</span><span class="n">phase_name</span><span class="p">)</span>

    <span class="c1"># process all the parameters that got added with dbf.add_parameter</span>
    <span class="n">dbf</span><span class="o">.</span><span class="n">process_parameter_queue</span><span class="p">()</span></div>

<span class="n">Database</span><span class="o">.</span><span class="n">register_format</span><span class="p">(</span><span class="s2">"dat"</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="n">read_cs_dat</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>

        <div class="related-information">
              Copyright &#169; 2015, pycalphad Development Team |
            Built with <a href="https://www.sphinx-doc.org/">Sphinx</a>
              and
              <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
              <a href="https://github.com/pradyunsg/furo">Furo theme</a>.
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/scripts/main.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>